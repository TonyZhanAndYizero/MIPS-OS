# Lab0

> 班级：222111
>
> 学号：22373340
>
> 姓名：詹佳博

## 思考题

### Thinking 0.1

<img src="C:\Users\28600\Desktop\OS\Lab0\5.jpg" alt="5" style="zoom:50%;" />

+ 首先进行创建文件操作，对此时的 `git` 进行分析，可知 `README.txt` 文件此时处于**未跟踪状态**==（`Untracked.txt`）==。
+ 然后进行修改文件操作，并且将修改后的文件使用 `git add` ，对此时的 `git` 进行分析，可知 `README.txt` 文件此时处于**暂存状态**==（`Stage.txt`）==。
+ 进行提交，正常使用 `git commit (-m)`  指令，此时文件进入**未修改状态**。
+ 此时执行两次 `cat` 指令来印证以上分析正确。
+ 然后进行修改文件操作，区别是将**已提交的文件进行修改**，对此时的 `git` 进行分析，可知 `README.txt` 文件此时处于**修改状态**==（`Modified.txt`）==。
+ 执行一次 `cat` 指令来印证以上分析正确。
  + 对于 `add` 之前的 `status` ，显然是不一样的。之前的并没有经过提交的文件修改，文件处于**未跟踪状态**；而现在明显是对提交的文件修改，文件就会处于**修改状态**。

### Thinking 0.2

+ `add the file`对应着 `git add $filename`
+ `stage the file`对应着 `git add $filename`
+ `commit`对应着 `git commit -m $message`

### Thinking 0.3

+ `git restore print.c`
+ `git reset HEAD print.c` 然后 `git checkout -- print.c`

+ `git rm --cached hello.txt` 或者 `git restore --staged hello.txt`

### Thinking 0.4

+ 前四步的行为使得 `git` 上出现三次提交记录。使用 `git log` 查看后发现事实如此。
  <img src="C:\Users\28600\Desktop\OS\Lab0\6.1.jpg" alt="6" style="zoom:50%;" />

+ 第五步进行版本回退，使得回退到 `HEAD^` 即上一个版本 (2) 。使用 `git log` 查看后发现事实如此。
  <img src="C:\Users\28600\Desktop\OS\Lab0\7.jpg" alt="7" style="zoom:50%;" />

+ 第六步使用哈希值进行版本回退，使得回退到版本 (1) 。使用 `git log` 查看后发现事实如此。
  <img src="C:\Users\28600\Desktop\OS\Lab0\8.jpg" alt="8" style="zoom:50%;" />

+ 第七步想回到最新版本 (3) ，使用 3 的哈希值。使用 `git log` 查看后发现事实如此。
  <img src="C:\Users\28600\Desktop\OS\Lab0\9.jpg" alt="9" style="zoom:50%;" />

### Thinking 0.5

+ `echo` 使得后面的参数回显。
  + 在 `first` 时，回显到屏幕；
  + 在 `second` 时，重定向输入到 `output.txt`；
  + 在 `third` 时，`>` 重定向输入到 `output.txt` 并且覆盖原文件；
  + 在 `forth` 时，`>>` 重定向输入到 `output.txt` 并且追加原文件；

<img src="C:\Users\28600\Desktop\OS\Lab0\10.jpg" alt="10" style="zoom:50%;" />

### Thinking 0.6

+ `command` 文件内容如下：
  <img src="C:\Users\28600\Desktop\OS\Lab0\11.jpg" alt="11" style="zoom:50%;" />

+ 运行 `command`。
  
+ 运行 `test`。
  
+ `result` 文件内容如下：
  <img src="C:\Users\28600\Desktop\OS\Lab0\14.jpg" alt="14" style="zoom:50%;" />

分析 `test` 代码（直接影响 `result` ）：

+ 首先，有一些 `echo` 指令在屏幕上输出伪代码；但是，有一些 `echo` 指令包含重定向符号，意味着将其后的内容**输入到重定向文件**中，如果还包含 `$` 符号，则就是将它的 *值* 代入。

+ 而没有 `echo` 的指令，紧跟在 `echo` 后，是真正的在**shell**中执行了、赋值了的指令；如果还包含 `$` 符号，则就是将它的 *值* 代入。

+ 以上分析即包含 `test` 所有行分析。以下为影响 `result` 的代码。
  ```shell
  a=1
  b=2
  c=$[$a+$b]
  echo $c>file1
  echo $b>file2
  echo $a>file3
  cat filel>file4
  cat file2>>file4
  cat file3>>file4
  cat file4>>result
  ```

分析 `command` 代码（直接影响 `test`）：

+ 所有的 `echo` 只是为了将后面所有东西输入到 `test` 文件，故而为字符串形式；需要区分的是，如果有一些包含了**重定向符号**及 `$` 符号等，会真实改变输出字符串形式，则用单引号括起来，保证其为原字符串输出。

echo echo Shell Start 与 echo \`echo Shell Start\` 效果有区别，前者是`echo Shell Start`，后者是`Shell Start`；

echo echo \$c>file1 与 echo \`echo \$c>file1\` 效果有区别，前者是将**echo <c的值>**输入到 `file1` 中，后者是将**<c的值>**输入到 `file1` 中。

## 难点分析

1. vim 太难用了，但是通过调整 .vimrc 文件使得显示变得让自己舒适了一些；在这几次使用中也慢慢稍微习惯了 vim 编写代码的用法。

2. 编写 Makefile 有时候逻辑顺序和依赖关系理不清，包括对 shell 命令的不熟悉也使得有时候错误较多；通过画依赖图来辅助编写 Makefile。
3. shell 编程有点像之前学的 python ，但是比python更难用。有时候对单引号、双引号和反引号的用法容易混淆。还有一些美元符和重定向符号的影响。
4. shell 命令太多，实在记不清楚；有时候必须得查阅手册来明确用法。
5. Makefile 有更加高级的 make 用法，目前还不能完全理解和掌握；同时，对 gcc 编译时，若已有 .o 文件，此时用 ld 链接好似还需要很复杂的一些参数，使用 gcc 则可以省一大笔事。这一点在课上完成 Exercise 0.4 困惑了很久很久。
6. git 操作的时候，由于不熟悉，有时候会忽略自己之前的改动，导致保留了自己不想改动的操作。
7. **上机**：如果循环较为复杂，涉及多管道和复杂指令合成，需要逐步写代码并仔细分析。

## 实验体会

1. 学习了基本的 shell 用法，会通过各种指令对文件进行操作。
2. 学习了基本的 gcc 编译，会进行编译、链接来构建可执行文件
3. 后悔没有好好的学习 man 的用法，只知道用教材上仅有的一些指令参数进行编程。考试还剩3分钟时通过 man 指令查询了grep的更多的一些用法，总算通过循环和查找完成了 extra 测试。以后要熟练学习使用 man ！
