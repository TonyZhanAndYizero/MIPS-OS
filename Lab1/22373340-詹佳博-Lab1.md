# Lab1

> 班级：222111
>
> 学号：22373340
>
> 姓名：詹佳博

## 思考题

### Thinking 1.1

思考框架：

 <img src="C:\Users\28600\Desktop\OS\Lab1\1.1-0.png" alt="1.1-0" style="zoom:40%;" />

+ $\texttt{x86}$ ：
  <img src="C:\Users\28600\Desktop\OS\Lab1\1.1-5.jpg" alt="1.1-5" style="zoom:40%;" />
  + 只编译不链接的解析（反汇编）结果 ( $\texttt{./x86/hello.objdump}$ )：
    <img src="C:\Users\28600\Desktop\OS\Lab1\1.1-1.jpg" alt="1.1-1" style="zoom:40%;" />
  + 编译并链接的解析（反汇编）结果 ( $\texttt{./x86/hello.exeobjdump}$​ )：
    <img src="C:\Users\28600\Desktop\OS\Lab1\1.1-2.jpg" alt="1.1-2" style="zoom:40%;" />
  + 注意到 $\texttt{call}$ 指令在链接之后**被填入地址**了。
+ $\texttt{mips}$ ：
  <img src="C:\Users\28600\Desktop\OS\Lab1\1.1-6.jpg" alt="1.1-6" style="zoom:40%;" />
  + 只编译不链接的解析（反汇编）结果 ( $\texttt{./mips/hello.objdump}$​ )：
    <img src="C:\Users\28600\Desktop\OS\Lab1\1.1-3.jpg" alt="1.1-3" style="zoom:40%;" />
  + 编译并链接的解析（反汇编）结果 ( $\texttt{./mips/hello.exeobjdump}$​ )：
    <img src="C:\Users\28600\Desktop\OS\Lab1\1.1-4.jpg" alt="1.1-4" style="zoom:40%;" />
  + 注意到在第 5 - 10 行的指令在链接之后**被填入地址**了。
+ 解释其中向 $\texttt{objdump}$​ 传入的参数的含义：即 $\texttt{objdump -D -S}$ 。
  + 其中 $\texttt{-D(--disassemble-all)}$ 代表从 objfile 中反汇编所有指令机器码的 section ；
  + 其中 $\texttt{-S(--source)}$ 代表尽可能反汇编出源代码。

### Thinking 1.2

+ 执行 $\texttt{./readelf}$
  +  <img src="C:\Users\28600\Desktop\OS\Lab1\1.2-1.jpg" alt="1.2-1" style="zoom:40%;" />
+ 使用 $\texttt{readelf -h}$
  +  <img src="C:\Users\28600\Desktop\OS\Lab1\1.2-2.jpg" alt="1.2-2" style="zoom:40%;" />
  + 结合 $\texttt{Makefile}$ 可知，对 $\texttt{readelf}$ 和 $\texttt{hello}$ 文件的编译命令不同。可知对**后者**的参数多加了 $\texttt{-m32 -static -g}$ 。分析可知，$\texttt{hello}$ 为 32 位代码，而 $\texttt{readelf}$ 为 **64** 位代码。阅读 $\texttt{readelf.c}$ 可知，我们所编写的程序只能解析 $\texttt{Elf32}$ ，即 32 位代码。

### Thinking 1.3

+ MOS 操作系统的目标是在 QEMU 模拟器上运行，故而启动这个过程被大大简化了。QEMU 支持加载 ELF 内核，所以启动流程被简化为**加载内核到内存**，之后**跳转到内核的入口**，启动就完成了。
+ 故而，实验操作系统先将内核入口按照内存布局图放置，通过所编写的 $\texttt{kernel.lds}$ 文件，将内核调整到正确的位子上，即**加载内核到内存**（由我们编写）；之后，在该文件头有两行代码，第一行规定架构为 mips，第二行规定程序的入口为 _start 这个函数，此时就可以**跳转到内核的入口**（由操作系统运行），也就是该函数。

## 难点分析

1. 在完成 $\texttt{readelf.c}$​ 函数时，对传入的 void *binary 一开始不理解，后来观察 ELF 结构，了解到 binary 指向 ELF 头，当我们想访问节头表时候，只需要将该指针往后移动到节头表位置即可。这个移动的距离只需要**调用 binary 指向的 ELF 头中所存储的位移距离**即可。移动到该位置之后，即可对指针进行强制类型转换，变为节头表，从而进一步访问其指向内存的内容，如 address 等。
2. 在完成 $\texttt{Exercise 1.3}$​ 时，要设置 sp 寄存器到内核栈空间。我编写的代码将其设置到了该空间的栈顶。一开始并不是很理解，后来想到栈的增长方向是向下增长的，指向栈顶也就可以防止栈溢出等。
3. $\texttt{Exercise 1.4}$ 的逻辑框架复杂，用流程图表示如下：
   <img src="C:\Users\28600\Desktop\OS\Lab1\难点-1.png" alt="难点-1" style="zoom: 20%;" />

## 实验体会

1. 在完成 $\texttt{Thinking 1.2}$ 时，误判断影响原因是两个程序的类型不同。一个是EXEC，一个是DYN，后来知道了这两个的区别是是否使用了静态库的区别。后者更为灵活，可能不包含程序执行的所有代码。
2. 在完成 $\texttt{Exercise 1.4}$ 时，第一次编写没有时刻初始化各个 flag 的值。这是个人疏忽，在编写时没有理清思路。最后还是通过流程图来理清编写过程。流程图对复杂的逻辑函数编写有着非常重要的作用。
3. 在做实验的 extra 的时候，while的逻辑循环判断错误了，导致丢分。以后得仔细看看自己逻辑判断是否正确。
